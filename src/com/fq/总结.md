## 无重复的最长子串

public class 无重复字符的最长字串 {

    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int maxLength = 0;
        int i = 0, j = 0;
        while(true) {
            if (j < s.length()) {
                if (set.contains(s.charAt(j))) {
                    maxLength = Math.max(maxLength, j - i);
                    set.remove(s.charAt(i));
                    i++;
                } else {
                    set.add(s.charAt(j));
                    j++;
                }
            } else {
                if (i < j) {
                    if (set.contains(s.charAt(j - 1))) {
                        maxLength = Math.max(maxLength, j - i);
                        set.remove(s.charAt(i));
                        i++;
                    }
                } else if (i == j) {
                    break;
                }
            }
        }
        return maxLength;
    }
}

## 二维数组的查找

    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int[] row = matrix[0];
        int width = row.length;
        int i = 0;
        int j = width - 1;
        while(true) {
            if (target < matrix[i][j]) {
                j--;
            } else if (target > matrix[i][j]) {
                i++;
            } else {
                return true;
            }
            if (i >= matrix.length || j < 0) {
                return false;
            }
        }
    }

## 全排列

    private List<List<Integer>> result = new ArrayList<>();

    private int[] nums;

    private boolean[] visited;

    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length == 0) {
            return result;
        }
        this.nums = nums;
        this.visited = new boolean[nums.length];
        helper(new ArrayList<>());
        return result;
    }

    private void helper(List<Integer> list) {
        if (list.size() == nums.length) {
            result.add(new ArrayList<>(list));
            return;
        }
        // 从头开始遍历
        for (int i = 0; i < nums.length; i++) {
            // 如果没有被访问过，则添加进结果
            if (!visited[i]) {
                list.add(nums[i]);
                visited[i] = true;
                helper(list);
                visited[i] = false;
                list.remove(list.size() - 1);
            }
        }
    }
    
## 全排列II

    private int[] nums;
    private List<List<Integer>> result = new ArrayList<>();
    private boolean[] visited;

    public List<List<Integer>> permuteUnique(int[] nums) {
        this.nums = nums;
        Arrays.sort(this.nums);
        visited = new boolean[nums.length];
        helper(new ArrayList<>());
        return result;
    }

    private void helper(List<Integer> subList) {
        if (subList.size() == this.nums.length) {
            result.add(new ArrayList<>(subList));
        }
        for (int i = 0; i < this.nums.length; i++) {
            // 去重
            if (i > 0 && nums[i - 1] == nums[i] && !visited[i - 1]) {
                continue;
            }
            if (!visited[i]) {
                visited[i] = true;
                subList.add(this.nums[i]);
                helper(subList);
                subList.remove(subList.size() - 1);
                visited[i] = false;
            }
        }
    } 
    
## 复原ip地址

public class 复原IP地址 {

    public List<String> restoreIpAddresses(String s) {
        int len = s.length();
        List<String> res = new ArrayList<>();
        if (len > 12 || len < 4) {
            return res;
        }

        Deque<String> path = new ArrayDeque<>(4);
        dfs(s, len, 0, 4, path, res);
        return res;
    }

    // 需要一个变量记录剩余多少段还没被分割

    private void dfs(String s, int len, int begin, int residue, Deque<String> path, List<String> res) {
        if (begin == len) {
            if (residue == 0) {
                res.add(String.join(".", path));
            }
            return;
        }
        for (int i = begin; i < begin + 3; i++) {
            if (i >= len) {
                break;
            }

            if (residue * 3 < len - i) {
                continue;
            }

            if (judgeIpSegment(s, begin, i)) {
                String currentIpSegment = s.substring(begin, i + 1);
                path.addLast(currentIpSegment);
                dfs(s, len, i + 1, residue - 1, path, res);
                path.removeLast();
            }
        }
    }

    private boolean judgeIpSegment(String s, int left, int right) {
        int len = right - left + 1;
        if (len > 1 && s.charAt(left) == '0') {
            return false;
        }

        int res = 0;
        while (left <= right) {
            res = res * 10 + s.charAt(left) - '0';
            left++;
        }

        return res >= 0 && res <= 255;
    }
}

    
## 机器人的运动范围

    private int m;
    private int n;
    private boolean[][] visited;

    public int movingCount(int m, int n, int k) {
        if (m == 0 || n == 0) {
            return 0;
        }
        if (k == 0) {
            return 1;
        }
        this.m = m;
        this.n = n;
        this.visited = new boolean[m][n];
        return helper(0, 0, k, 0);
    }

    private int helper(int i, int j, int k, int count) {
        if (i > m - 1 || i < 0 || j > n - 1 || j < 0) {
            return 0;
        }
        if (calculate(i) + calculate(j) > k) {
            return 0;
        }
        // 此时是符合条件 则占位
        if (!visited[i][j]) {
            visited[i][j] = true;
            // 上下左右
            return helper(i + 1, j, k, count + 1)
                    + helper(i - 1, j, k, count + 1)
                    + helper(i, j + 1, k, count + 1)
                    + helper(i, j - 1, k, count + 1)
                    + 1;
        }
        return 0;
    }

    private int calculate(int num) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }
    
## 电话号码的组合

    /**
     * 首先填充数字和字符串的对应关系,这里使用数组直接表示
     */
    private String[] mapping = new String[]{
      "",
      "",
      "abc",
      "def",
      "ghi",
      "jkl",
      "mno",
      "pqrs",
      "tuv",
      "wxyz"
    };

    private String digits;
    private List<String> result = new ArrayList<>();


    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return result;
        }
        this.digits = digits;
        helper(0, new StringBuilder());
        return result;
    }

    private void helper(int start, StringBuilder stringBuilder){
        if (start == digits.length() - 1) {
            result.add(new String(stringBuilder));
            return;
        }
        // 给定字符串start位置所对应的的数字
        int index = digits.charAt(start) - '0';
        for (int i = 0; i < mapping[index].length(); i++) {
            // 加入结果集
            stringBuilder.append(mapping[index].charAt(i));
            helper(start + 1, stringBuilder);
            stringBuilder.deleteCharAt(stringBuilder.length() - 1);
        }
    }

## 矩阵中的路径

    private char[][] board;

    private boolean[][] visited;

    public boolean exist(char[][] board, String word) {
        // 特判
        if (board.length == 0 || word.length() == 0) {
            return false;
        }
        this.board = board;
        visited = new boolean[board.length][board[0].length];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (helper(i, j, word, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean helper(int i, int j, String word, int index) {
        if (index == word.length()) {
            return true;
        }
        // 如果超出范围了
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
            return false;
        }
        // 如果没有被访问
        if (!visited[i][j]) {
            char c = word.charAt(index);
            if (c == board[i][j]) {
                visited[i][j] = true;
                // 上下左右
                boolean b1 = helper(i - 1, j, word, index + 1);
                boolean b2 = helper(i + 1, j, word, index + 1);
                boolean b3 = helper(i, j - 1, word, index + 1);
                boolean b4 = helper(i, j + 1, word, index + 1);
                visited[i][j] = false;
                return b1 || b2 || b3 || b4;
            } else {
                return false;
            }
        }
        return false;
    }

## 单词接龙

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        //  获取单词长度
        int length = beginWord.length();
        // 生成联合字典
        Map<String, List<String>> combinationMap = new HashMap<>(wordList.size());
        wordList.forEach(word -> {
            for (int i = 0; i < length; i++) {
                // 生成带 * 的单词
                String newWord = word.substring(0, i) + "*" + word.substring(i + 1, length);
                List<String> list = combinationMap.getOrDefault(newWord, new ArrayList<>());
                list.add(word);
                combinationMap.put(newWord, list);
            }
        });
        Queue<Pair<String, Integer>> queue = new LinkedList<>();
        queue.add(new Pair<>(beginWord, 1));

        Map<String, Boolean> visitedMap = new HashMap<>(wordList.size());
        visitedMap.put(beginWord, true);

        while(!queue.isEmpty()) {
            Pair<String, Integer> poll = queue.poll();
            String key = poll.getKey();
            Integer level = poll.getValue();
            for (int i = 0; i < key.length(); i++) {
                String newWord =  key.substring(0, i) + "*" + key.substring(i + 1, length);
                for (String exactWord: combinationMap.getOrDefault(newWord, new ArrayList<>())) {
                    if (exactWord.equals(endWord)) {
                        return level + 1;
                    }
                    if (!visitedMap.containsKey(exactWord)) {
                        visitedMap.put(exactWord, true);
                        queue.offer(new Pair<>(exactWord, level + 1));
                    }
                }
            }
        }
        return 0;
    }
    
## 岛屿数量

    char[][] grid;
    int maxX;
    int maxY;


    public int numIslands(char[][] grid) {
        this.grid = grid;
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        this.maxX = grid.length;
        this.maxY = grid[0].length;
        int result = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                // 如果为1 则深度优先遍历将周围都置为0 并且结果++
                if (this.grid[i][j] == '1') {
                    result++;
                    dfs(i, j);
                }
            }
        }
        return result;

    }

    private void dfs(int x, int y) {
        if (!inArea(x, y) || this.grid[x][y] == '0') {
            return;
        }
        this.grid[x][y] = '0';
        dfs(x - 1, y);
        dfs(x, y + 1);
        dfs(x + 1, y);
        dfs(x, y - 1);
    }

    private boolean inArea(int x, int y) {
        return x >= 0 && x < this.maxX && y >= 0 && y < maxY;
    }

## 零一矩阵

    public int[][] updateMatrix(int[][] matrix) {
        // 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1
        Queue<int[]> queue = new LinkedList<>();
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    queue.offer(new int[] {i, j});
                } else {
                    matrix[i][j] = -1;
                }
            }
        }

        int[] dx = new int[] {-1, 1, 0, 0};
        int[] dy = new int[] {0, 0, -1, 1};
        while (!queue.isEmpty()) {
            int[] point = queue.poll();
            int x = point[0], y = point[1];
            for (int i = 0; i < 4; i++) {
                int newX = x + dx[i];
                int newY = y + dy[i];
                // 如果四邻域的点是 -1，表示这个点是未被访问过的 1
                // 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1。
                if (newX >= 0 && newX < m && newY >= 0 && newY < n
                        && matrix[newX][newY] == -1) {
                    matrix[newX][newY] = matrix[x][y] + 1;
                    queue.offer(new int[] {newX, newY});
                }
            }
        }

        return matrix;
    }

## 二分查找

    public int search(int[] nums, int target) {
        int mid, left = 0, right = nums.length - 1;
        while(left <= right) {
            mid = (right - left) / 2 + left;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
## 寻找旋转排序数组中的最小值

    public int findMin(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int i = 0, j = nums.length - 1;
        while(nums[j] < nums[i]) {
            int mid = (j + i) / 2;
            if (nums[i] < nums[mid]) {
                i = mid;
            } else {
                j = mid;
            }
        }
        return Math.min(nums[i], nums[i + 1]);
    }
    
## 寻找数组的最小数字

    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while(left < right) {
            int mid = (right - left) / 2 + left;
            if(numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else if(numbers[mid] == numbers[right]) {
                // 如果相等只能右边指针往左移
                right--;
            } else {
                right = mid;
            }
        }
        return numbers[left];
    }
    
## 1到n中1出现的次数

    private int times = 0;

    // 别整数学 就循环递归
    public int countDigitOne(int n) {
        for (int i = 1; i <= n; i++) {
            calculate(i);
        }
        return times;
    }

    private void calculate(int n) {
        while (n > 0) {
            if (n % 10 == 1) {
                times++;
            }
            n /= 10;
        }
    }
    
## 二进制的1

    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            if ((n & 1) != 0) {
                count++;
            }
            n = n >>> 1;
        }
        return count;
    }
    
## LRU

    class DLinkedNode {
        int key;
        int value;
        DLinkedNode pre;
        DLinkedNode next;
    }

    private HashMap<Integer, DLinkedNode> cache = new HashMap<>();

    private int count;
    private int capacity;

    private DLinkedNode head, tail;

    public LRU(int capacity) {
        this.count = 0;
        this.capacity = capacity;
        head = new DLinkedNode();
        head.pre = null;
        tail = new DLinkedNode();
        tail.next = null;
        // 头尾相连
        head.next = tail;
        tail.pre = head;
    }

    private void add(DLinkedNode node) {
        node.pre = head;
        node.next = head.next;

        head.next.pre = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        DLinkedNode pre = node.pre;
        DLinkedNode next = node.next;

        pre.next = next;
        next.pre = pre;
    }

    private void removeToHead(DLinkedNode node) {
        removeNode(node);
        add(node);
    }

    private DLinkedNode popTail(){
        DLinkedNode res = tail.pre;
        removeNode(res);
        return res;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);

        if (node == null) {
            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.value = value;
            this.cache.put(key, newNode);
            add(newNode);
            count++;
            if (count > capacity) {
                DLinkedNode tail = this.popTail();
                this.cache.remove(tail.key);
                count--;
            }
        } else {
            node.value = value;
            this.removeToHead(node);
        }
    }

## 三数之和

    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // 排序
        Arrays.sort(nums);
        // 首先固定一位
        for (int i = 0; i < nums.length - 2; i++) {
            int fixedNum = nums[i];
            // 如果当前数和前面一个相等则直接continue
            if (i > 0 && fixedNum == nums[i - 1]) {
                continue;
            }
            int j = i + 1;
            int k = nums.length - 1;
            while(j < k) {
                int sum = fixedNum + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    List<Integer> elementList = Arrays.asList(fixedNum, nums[j], nums[k]);
                    result.add(elementList);
                    // 下面去重 主要应对这种情况[-2,0,0,2,2]，[-2,0,0,1,2]
                    while(j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    while(j < k && nums[k] == nums[k - 1]) {
                        k--;
                    }
                    j++;
                    k--;
                }
            }
        }
        return result;
    }
    
## 两数之和 有序数组

    public int[] twoSum(int[] numbers, int target) {
        int i = 0, j = numbers.length - 1;
        while(i < j) {
            if(numbers[i] + numbers[j] > target) {
                j--;
            } else if(numbers[i] + numbers[j] < target) {
                i++;
            } else {
                return new int[]{i + 1, j + 1};
            }
        }
        return null;
    }
    
## 和为s的连续正数序列

    public int[][] findContinuousSequence(int target) {
        List<int[]> result = new ArrayList<>();
        int[] nums = new int[target + 1];
        for(int i = 1; i < nums.length; i++) {
            nums[i] = i;
        }
        int curNum = 1;
        for(int left = 1, right = 1;;) {
            if (left == right && left != 1) {
                break;
            }
            if(curNum < target) {
                curNum += nums[++right];
            } else if(curNum > target) {
                curNum -= nums[left];
                left++;
            } else {
                int[] subArray = new int[right - left + 1];
                for(int k = left, l = 0; k <= right; k++, l++) {
                    subArray[l] = k;
                }
                result.add(subArray);
                curNum += nums[++right];
            }
        }
        int[][] out = new int[result.size()][];
        return result.toArray(out);
    }

## 无重复字符的最长子串

    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int maxLength = 0;
        int i = 0, j = 0;
        while(true) {
            if (j < s.length()) {
                if (set.contains(s.charAt(j))) {
                    maxLength = Math.max(maxLength, j - i);
                    set.remove(s.charAt(i));
                    i++;
                } else {
                    set.add(s.charAt(j));
                    j++;
                }
            } else {
                if (i < j) {
                    if (set.contains(s.charAt(j - 1))) {
                        maxLength = Math.max(maxLength, j - i);
                        set.remove(s.charAt(i));
                        i++;
                    }
                } else if (i == j) {
                    break;
                }
            }
        }
        return maxLength;
    }

## 盛最多水的容器

    public int maxArea(int[] height) {
        // 双指针 贪心思想
        int maxArea = 0;
        for (int i = 0, j = height.length - 1; j > i;) {
            maxArea = Math.max(Math.min(height[i],height[j]) * (j - i), maxArea);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return maxArea;
    }
 
 ## 三角形的最小路径和
 
     public int minimumTotal(List<List<Integer>> triangle) {
         if (triangle == null || triangle.size() == 0) {
             return 0;
         }
         int[][] dp = new int[triangle.size() + 1][triangle.size() + 1];
         for (int i = triangle.size() - 1; i >= 0 ; i--) {
             for (int j = i; j >= 0; j--) {
                 // dp记录着 该点到最后一行的最小距离
                 dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + 1][j], dp[i + 1][j + 1]);
             }
         }
         return dp[0][0];
     }
     
## 不同二叉搜索树个数

    public int numTrees(int n) {

        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
 
## 剪绳子

    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(Math.max(dp[j] * (i - j), dp[i]), j * (i - j));
            }
        }
        return dp[n];
    }
    
## 打家劫舍

    public int rob(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i < nums.length; i++) {
            // 动态转移方程 dp[i] = max{dp[i - 1],dp[i - 2] + nums[i]}
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.length - 1];
    }
 
 ## 打家劫舍II
 
     public int rob(int[] nums) {
         // 其实和打家劫舍I差不多， 这里主要要考虑首尾是相连的
         // 所以只要考虑这两种特殊情况就行了
         // 比如偷第一个不偷最后一个、偷最后一个不偷第一个
         if (nums.length == 0) {
             return 0;
         }
         if (nums.length == 1) {
             return nums[0];
         }
         return Math.max(helper(Arrays.copyOfRange(nums, 0, nums.length - 1)),
                 helper(Arrays.copyOfRange(nums, 1, nums.length)));
     }
 
     private int helper(int[] nums) {
         int[] dp = new int[nums.length + 1];
         dp[0] = 0;
         dp[1] = nums[0];
         for (int i = 2; i < dp.length; i++) {
             dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
         }
         return dp[dp.length - 1];
     }
     
 ## 打家劫舍III
 
     public class Solution {
 
         // 树的后序遍历
         public int rob(TreeNode root) {
             int[] res = dfs(root);
             return Math.max(res[0], res[1]);
         }
 
         private int[] dfs(TreeNode node) {
             if (node == null) {
                 return new int[]{0, 0};
             }
             // 分类讨论的标准是：当前结点偷或者不偷
             // 由于需要后序遍历，所以先计算左右子结点，然后计算当前结点的状态值
             int[] left = dfs(node.left);
             int[] right = dfs(node.right);
 
             // dp[0]：以当前 node 为根结点的子树能够偷取的最大价值，规定 node 结点不偷
             // dp[1]：以当前 node 为根结点的子树能够偷取的最大价值，规定 node 结点偷
             int[] dp = new int[2];
             // 左右节点的情况返回给父节点
             // 如果当前节点不偷 那么取左右孩子所有情况的最大值
             dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
             // 如果当前节点偷 那么左右孩子都不能偷
             dp[1] = node.val + left[0] + right[0];
             return dp;
         }
     }
 
 
     /**
      * [2,1,3,null,4]
      * 并不是简单的隔代，比如父亲层级的右节点和父亲层左节点的孩子是不相连的。。。
      * @param root 根
      * @return 最大value
      */
     public static int robFailure(TreeNode root) {
         if (root == null) {
             return 0;
         }
         // 首先层序遍历 计算每一层总数
         Queue<TreeNode> queue = new LinkedList<>();
         queue.offer(root);
         // 存放每一层总数
         List<Integer> sumList = new ArrayList<>();
         while (!queue.isEmpty()) {
             // 循环计算一层的总数
             int sum = 0;
             int queueLength = queue.size();
             for (int i = 0; i < queueLength; i++) {
                 TreeNode poll = queue.poll();
                 sum += poll.val;
                 if (poll.left != null) {
                     queue.offer(poll.left);
                 }
                 if (poll.right != null) {
                     queue.offer(poll.right);
                 }
             }
             // 加入 sumList
             sumList.add(sum);
         }
         StringBuilder stringBuilder = new StringBuilder();
         sumList.forEach(element -> stringBuilder.append(",").append(element));
         System.out.println(stringBuilder);
         // 现在归结为打家劫舍最初的题目了 即相邻的不能偷
         if (sumList.size() == 1) {
             return sumList.get(0);
         }
         int[] dp = new int[sumList.size()];
         dp[0] = sumList.get(0);
         dp[1] = Math.max(sumList.get(0), sumList.get(1));
         for (int i = 2; i < sumList.size(); i++) {
             dp[i] = Math.max(dp[i - 2] + sumList.get(i), dp[i - 1]);
         }
         return dp[sumList.size() - 1];
     }
     
## 最大乘积子序列


    public int maxProduct(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        int max = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] >= 0) {
                dp[i][0] = Math.max(dp[i - 1][0] * nums[i], nums[i]);
                dp[i][1] = Math.min(dp[i - 1][1] * nums[i], nums[i]);
            } else {
                dp[i][0] = Math.max(dp[i - 1][1] * nums[i], nums[i]);
                dp[i][1] = Math.min(dp[i - 1][0] * nums[i], nums[i]);
            }
            max = Math.max(max, dp[i][0]);
            max = Math.max(max, dp[i][1]);
        }
        return max;
    }
    
## 最小花费

    public static int minSpend(int price) {
        boolean[] dp = new boolean[price + 1];
        dp[0] = true;
        if (price >= 11) {
            dp[11] = true;
        }
        if (price >= 30) {
            dp[30] = true;
        }
        if (price >= 40) {
            dp[40] = true;
        }
        int max = 0;
        for (int i = 1; i < dp.length; i++) {
            boolean b3 = false;
            boolean b11 = false;
            boolean b5 = false;
            if (i >= 11) {
                b3 = dp[i - 11];
            }
            if (i >= 30) {
                b5 = dp[i - 30];
            }
            if (i >= 40) {
                b11 = dp[i - 40];
            }
            dp[i] = b3 || b5 || b11;
            if (dp[i]) {
                max = i;
            }
        }
        return price - max;
    }

## 最小路径和

    private int m;
    private int n;
    private boolean inArea(int i, int j) {
        return !(i < 0 || i >= m || j < 0 || j >= n);
    }

    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.m = grid.length;
        this.n = grid[0].length;
        int[][] dp = new int[m][n];
        // 初始化dp最后的
        for (int i = grid.length - 1; i >= 0; i--) {
            for (int j = grid[i].length - 1; j >= 0; j--) {
                if (inArea(i + 1, j)) {
                    if (inArea(i, j + 1)) {
                        // 此时则可以使用方程
                        dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);
                    } else {
                        // 此时说明右边越界 则只能是下边
                        dp[i][j] = grid[i][j] + dp[i + 1][j];
                    }
                } else {
                    // 此时下边越界，则首先判断是否右边没越界
                    if (inArea(i, j + 1)) {
                        dp[i][j] = grid[i][j] + dp[i][j + 1];
                    } else {
                        // 此时其实它就是右下角
                        dp[i][j] = grid[i][j];
                    }
                }
            }
        }
        return dp[0][0];
    }
    
 ## 最长上升子序列
 
     public int lengthOfLIS(int[] nums) {
         if(nums.length == 0) {
             return 0;
         }
         int[] dp = new int[nums.length];
         Arrays.fill(dp, 1);
         int max = 1;
         for (int i = 0; i < dp.length; i++) {
             for (int j = 0; j < nums.length; j++) {
                 if (nums[i] > nums[j]) {
                     // 如果i位置大于 j位置 那么为 dp[i] = dp[j] + 1
                     dp[i] = Math.max(dp[i], dp[j] + 1);
                 }
             }
             max = Math.max(max, dp[i]);
         }
         return max;
     }

## 最长公共子序列

    public int longestCommonSubsequence(String text1, String text2) {
        int length1 = text1.length();
        int length2 = text2.length();
        int[][] dp = new int[length1 + 1][length2 + 1];
        for(int i = 0; i < length1; i++) {
            for(int j = 0; j < length2; j++) {
                if(text1.charAt(i) == text2.charAt(j)) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
                }
            }
        }
        return dp[length1][length2];
    }

## 最长回文子串

    public String longestPalindrome(String s) {
        int length = s.length();
        if (length < 2) {
            return s;
        }
        boolean[][] dp = new boolean[length][length];
        for (int i = 0; i < length; i++) {
            dp[i][i] = true;
        }
        int begin = 0;
        int maxLength = 1;
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                } else {
                    dp[i][j] = false;
                }
                if (dp[i][j] && j - i + 1 > maxLength) {
                    maxLength = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLength);
    }
    
 ## 等差数列划分
 
     public int numberOfArithmeticSlices(int[] A) {
         if (A.length < 3) {
             return 0;
         }
         int[] dp = new int[A.length];
         int sum = 0;
         for (int i = 2; i < dp.length; i++) {
             if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                 dp[i] = dp[i - 1];
             }
             sum += dp[i];
         }
         return sum;
     }
     
## 编辑距离

    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        // 如果其中有一个长度为0，那么直接返回结果
        if (m * n == 0) {
            return Math.max(m, n);
        }
        int[][] dp = new int[m + 1][n + 1];
        // 边界初始化
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i <= n; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 如果相等 那么就等于前面的
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 判断三种操作情况 取最小值
                    int insert = dp[i - 1][j];
                    int delete = dp[i][j - 1];
                    int update = dp[i - 1][j - 1];
                    int min = Math.min(insert, delete);
                    min = Math.min(min, update);
                    dp[i][j] = min + 1;
                }
            }
        }
        return dp[m][n];
    }

## 背包问题

    public int maxValue(int[] capacity, int[] value, int totalCapacity) {
        int length = capacity.length;
        int[][] dp = new int[length][totalCapacity + 1];
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                if (j - capacity[j] >= 0) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - capacity[j]] + value[j]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[capacity.length - 1][totalCapacity];
    }
    
 ## 零钱兑换
 
     public int coinChange(int[] coins, int amount) {
         int[] dp = new int[amount + 1];
         // 首先初始化 代表对于所有的数值都需要 amount + 1 这是最大值
         Arrays.fill(dp, amount + 1);
         dp[0] = 0;
         for(int i = 0; i < dp.length; i++) {
             for(int j = 0; j < coins.length; j++) {
                 if(coins[j] <= i) {
                     // 动归公式 dp[i] = dp[i - coins[j]] + 1
                     dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                 }
             }
         }
         return dp[amount] == amount + 1 ? -1 : dp[amount];
     }
     
## 鸡蛋掉落

    public int superEggDrop(int K, int N) {
        return dp(K, N);
    }

    Map<Integer, Integer> memo = new HashMap();
    public int dp(int K, int N) {
        if (!memo.containsKey(N * 100 + K)) {
            int ans;
            if (N == 0)
                ans = 0;
            else if (K == 1)
                ans = N;
            else {
                int lo = 1, hi = N;
                while (lo + 1 < hi) {
                    int x = (lo + hi) / 2;
                    int t1 = dp(K-1, x-1);
                    int t2 = dp(K, N-x);

                    if (t1 < t2)
                        lo = x;
                    else if (t1 > t2)
                        hi = x;
                    else
                        lo = hi = x;
                }

                ans = 1 + Math.min(Math.max(dp(K-1, lo-1), dp(K, N-lo)),
                        Math.max(dp(K-1, hi-1), dp(K, N-hi)));
            }

            memo.put(N * 100 + K, ans);
        }

        return memo.get(N * 100 + K);
    }

## 整数转罗马数字

    int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

    public String intToRoman(int num) {
        StringBuilder sb = new StringBuilder();
        // Loop through each symbol, stopping if num becomes 0.
        for (int i = 0; i < values.length && num >= 0; i++) {
            while (values[i] <= num) {
                num -= values[i];
                sb.append(symbols[i]);
            }
        }
        return sb.toString();
    }

## 两数之和

    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        int[] res = new int[2];
        for(int i = 0; i < length; i++) {
            if(map.containsKey(target - nums[i])) {
                res[0] = i;
                res[1] = map.get(target - nums[i]);
                return res;
            } else {
                map.put(nums[i], i);
            }
        }
        return res;
    }
    
## 两个链表的第一个公共节点

    // 双指针 快慢指针 总会相遇
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode nodeA = headA;
        ListNode nodeB = headB;
        while (nodeA != nodeB) {
            if (nodeA != null) {
                nodeA = nodeA.next;
            } else {
                nodeA = headB;
            }
            if (nodeB != null) {
                nodeB = nodeB.next;
            } else {
                nodeB = headA;
            }
        }
        return nodeA;
    }

## 两数相加

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        // 记录进位
        int carry = 0;
        while (l1 != null || l2 != null) {
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            int sum = x + y + carry;

            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);

            cur = cur.next;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry == 1) {
            cur.next = new ListNode(carry);
        }
        return pre.next;
    }
 
## 从尾打印链表

    private List<Integer> result = new ArrayList<>();

    public int[] reversePrint(ListNode head) {
        helper(head, result);
        int[] arr = new int[result.size()];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = result.get(i);
        }
        return arr;
    }

    private void helper(ListNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        helper(node.next, result);
        result.add(node.val);
    }

## 反转链表

    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }

    public ListNode reverseListRecurrence(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseListRecurrence(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
    
## 回文链表

    public boolean isPalindrome(ListNode head) {
        // 要实现 O(n) 的时间复杂度和 O(1) 的空间复杂度，需要翻转后半部分
        if (head == null || head.next == null) {
            return true;
        }
        ListNode fast = head;
        ListNode slow = head;
        // 根据快慢指针，找到链表的中点
        while(fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        slow = reverse(slow.next);
        while(slow != null) {
            if (head.val != slow.val) {
                return false;
            }
            head = head.next;
            slow = slow.next;
        }
        return true;
    }

    /**
     * 递归反转链表
     * @param head 头结点
     * @return 反转后的链表
     */
    private ListNode reverse(ListNode head){
        // 递归到最后一个节点，返回新的新的头结点
        if (head.next == null) {
            return head;
        }
        ListNode newHead = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }

## 排序链表

    public ListNode sortList(ListNode head) {
        // 快慢指针找到中间节点和尾结点
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head, fast = head.next.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        // 中间往右
        ListNode r = sortList(slow.next);
        // 断开链表
        slow.next = null;
        // 起点往右
        ListNode l = sortList(head);
        return merge(l, r);
    }

    private ListNode merge(ListNode left, ListNode right) {
        if (left == null || right == null) {
            return left == null ? right : left;
        }
        ListNode leftCur = left;
        ListNode rightCur = right;
        ListNode preNode = new ListNode(-1);
        ListNode curNode = preNode;
        while(true) {
            if (leftCur == null) {
                curNode.next = rightCur;
                break;
            }
            if (rightCur == null) {
                curNode.next = leftCur;
                break;
            }
            if (leftCur.val <= rightCur.val) {
                curNode.next = leftCur;
                leftCur = leftCur.next;
                continue;
            } else {
                curNode.next = rightCur;
                rightCur = rightCur.next;
            }
        }
        return preNode.next;
    }
    
 ## 环形链表
 
     public boolean hasCycle(ListNode head) {
         HashSet<ListNode> set = new HashSet<>();
         ListNode cur = head;
         while(cur != null) {
             if(!set.contains(cur)) {
                 set.add(cur);
             } else {
                 return true;
             }
             cur = cur.next;
         }
         return false;
     }

## 环形链表II

    public ListNode detectCycle(ListNode head) {
        HashSet<ListNode> hashSet = new HashSet<>();
        ListNode cur = head;
        while(cur != null) {
            if (hashSet.contains(cur)) {
                return cur;
            } else {
                hashSet.add(cur);
            }
            cur = cur.next;
        }
        return null;
    }
    
## 分发糖果

    public int candy(int[] ratings) {
        if (ratings.length == 0) {
            return 0;
        }
        if (ratings.length == 1) {
            return 1;
        }
        int[] nums = new int[ratings.length];
        nums[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                nums[i] = nums[i - 1] + 1;
            } else {
                nums[i] = 1;
            }
        }

        for (int i = nums.length - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] && nums[i] <= nums[i + 1]) {
                nums[i] = nums[i + 1] + 1;
            }
        }
        int count = 0;
        for (int num: nums) {
            count += num;
        }
        return count;

    }

## 分糖果

    public int distributeCandies(int[] candies) {
        // 使用set计算一共有多少种类
        // 如果种类小于一半 那妹妹最多拿一个种类的
        // 如果种类大于一半，那妹妹最多也只能拿一半
        Set<Integer> set = new HashSet<>();
        for (int element : candies) {
            set.add(element);
        }
        return Math.min(set.size(), candies.length / 2);
    }


## 构建乘积数列

    public int[] constructArr(int[] a) {
        int[] result = new int[a.length];

        for (int i = 0, product = 1; i < result.length;  product *= a[i], i++) {
            result[i] = product;
        }

        for (int i = result.length - 1, product = 1; i >= 0 ; product *= a[i], i--) {
            result[i] *= product;
        }
        return result;
    }
    
## 翻转整数

    public int reverse(int x) {
        long n = 0;
        while (x != 0) {
            n = n * 10 + x % 10;
            x = x / 10;
        }
        // 防止溢出
        return (int)n == n ? (int)n : 0;
    }

## N皇后

    private List<List<String>> result = new ArrayList<>();
    private boolean[] pie;
    private boolean[] na;
    private boolean[] columnVisited;
    private boolean[][] queueMap;
    private int n;

    public List<List<String>> solveNQueens(int n) {
        this.n = n;
        this.queueMap = new boolean[n][n];
        this.na = new boolean[2 * n - 1];
        this.pie = new boolean[2 * n - 1];
        this.columnVisited = new boolean[n];
        dfs(0);
        return result;
    }

    private void dfs(int level) {
        // 如果此时已经溢出 那么可以通过queueMap计算结果了
        if (level >= n) {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int j = 0; j < n; j++) {
                    stringBuilder.append(queueMap[i][j] ? "Q" : ".");
                }
                list.add(stringBuilder.toString());
            }
            result.add(list);
        }
        for (int j = 0; j < queueMap.length; j++) {
            // 如果都符合则放置Q 即设置queueMap指定位置为true
            if (!columnVisited[j] && !na[(j - level) + n - 1] && !pie[level + j]) {
                queueMap[level][j] = true;
                columnVisited[j] = true;
                pie[level + j] = true;
                na[(j - level) + n - 1] = true;
                dfs(level + 1);
                // 此时进行回溯
                queueMap[level][j] = false;
                columnVisited[j] = false;
                pie[level + j] = false;
                na[(j - level) + n - 1] = false;
            }
        }
    }
    
## 有效的数独

    public boolean isValidSudoku(char[][] board) {
        // 判断每行中是否有重复元素
        for (int i = 0; i < 9; i++) {
            Set<Character> set = new HashSet<>();
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    continue;
                }
                if (set.contains(board[i][j])) {
                    return false;
                } else {
                    set.add(board[i][j]);
                }
            }
        }
        for (int i = 0; i < 9; i++) {
            Set<Character> set = new HashSet<>();
            for (int j = 0; j < 9; j++) {
                if (board[j][i] == '.') {
                    continue;
                }
                if (set.contains(board[j][i])) {
                    return false;
                } else {
                    set.add(board[j][i]);
                }
            }
        }
        for (int i = 0; i < 9; i++) {
            int jstart = i / 3;
            int kstart = i % 3;
            Set<Character> set = new HashSet<>();
            for (int j = jstart * 3; j < jstart * 3 + 3; j++) {
                for (int k = kstart * 3; k < kstart * 3 + 3; k++) {
                    if (board[j][k] == '.') {
                        continue;
                    }
                    if (set.contains(board[j][k])) {
                        return false;
                    } else {
                        set.add(board[j][k]);
                    }
                }
            }
        }
        return true;
    }
    
## 解数独

    public void solveSudoku(char[][] board) {
        /**
         * 记录某行，某位数字是否已经被摆放
         */
        boolean[][] row = new boolean[9][9];
        /**
         * 记录某列，某位数字是否已经被摆放
         */
        boolean[][] col = new boolean[9][9];
        /**
         * 记录某 3x3 宫格内，某位数字是否已经被摆放
         */
        boolean[][] block = new boolean[9][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '1';
                    row[i][num] = true;
                    col[j][num] = true;
                    // blockIndex = i / 3 * 3 + j / 3，取整
                    block[i / 3 * 3 + j / 3][num] = true;
                }
            }
        }
        dfs(board, row, col, block, 0, 0);
    }

    private boolean dfs(char[][] board, boolean[][] row, boolean[][] col, boolean[][] block, int i, int j) {
        // 找寻空位置
        while (board[i][j] != '.') {
            if (++j >= 9) {
                i++;
                j = 0;
            }
            if (i >= 9) {
                return true;
            }
        }
        for (int num = 0; num < 9; num++) {
            int blockIndex = i / 3 * 3 + j / 3;
            if (!row[i][num] && !col[j][num] && !block[blockIndex][num]) {
                // 递归
                board[i][j] = (char) ('1' + num);
                row[i][num] = true;
                col[j][num] = true;
                block[blockIndex][num] = true;
                if (dfs(board, row, col, block, i, j)) {
                    return true;
                } else {
                    // 回溯
                    row[i][num] = false;
                    col[j][num] = false;
                    block[blockIndex][num] = false;
                    board[i][j] = '.';
                }
            }
        }
        return false;
    }

    private void printBoard(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
    }

## 队列的最大值

    class MaxQueue {

        Queue<Integer> dataQueue;
        Deque<Integer> maxDeque;

        public MaxQueue() {
            dataQueue = new LinkedList<>();
            maxDeque = new LinkedList<>();
        }

        public int max_value() {
            if (maxDeque.isEmpty()) {
                return -1;
            }
            return maxDeque.peekFirst();
        }

        // 同时维护两个队列 数据队列直接入队
        // 最大队列维护一个单调下降队列 当插入的时候比最后一个大
        // 则将最后一个移除再插入
        public void push_back(int value) {
           dataQueue.offer(value);
           while (!maxDeque.isEmpty()) {
               if (maxDeque.peekLast() < value) {
                   maxDeque.pollLast();
               }
           }
           maxDeque.offerLast(value);
        }

        public int pop_front() {
            // 如果 maxDeque的最后一个和数据队列中的队首一样则一起出队
            // 否则只要出队dataQueue
            if(dataQueue.peek()!=null && maxDeque.peekFirst()!=null){
                if((int)dataQueue.peek()==(int)maxDeque.peekFirst()){
                    maxDeque.pollFirst();
                }
                return (int)dataQueue.poll();
            }else{
                return -1;
            }
        }

    }
    
## 二十四点

    public boolean judgePoint24(int[] nums) {
        List<Double> list = new ArrayList<>();
        for (int num : nums) {
            list.add((double )num);
        }
        return helper(list);
    }

    private boolean helper(List<Double> list) {
        if (list.size() == 0) {
            return false;
        }
        if (list.size() == 1) {
            return Math.abs(list.get(0) - 24) < 1e-6;
        }
        for (int i = 0; i < list.size(); i++) {
            for (int j = 0; j < list.size(); j++) {
                if (i == j) {
                    continue;
                }
                List<Double> newList = new ArrayList<>();
                for (int k = 0; k < list.size(); k++) {
                    if (k != i && k != j) {
                        newList.add((double)list.get(k));
                    }
                }
                double a = list.get(i);
                double b = list.get(j);
                newList.add(a + b);
                if (helper(newList)) {
                    return true;
                }
                newList.remove(newList.size() - 1);
                newList.add(a - b);
                if (helper(newList)) {
                    return true;
                }
                newList.add(a * b);
                newList.remove(newList.size() - 1);
                if (helper(newList)) {
                    return true;
                }
                newList.remove(newList.size() - 1);
                if (b != 0) {
                    newList.add(a / b);
                    if (helper(newList)) {
                        return true;
                    }
                    newList.remove(newList.size() - 1);
                }
            }
        }
        return false;
    }

## 岛屿最大面积

    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    max = Math.max(dfs(grid, i, j), max);
                }
            }
        }
        return max;
    }

    int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }
        grid[i][j] = 0;
        int count = 1;
        count += dfs(grid, i + 1, j);
        count += dfs(grid, i - 1, j);
        count += dfs(grid, i, j + 1);
        count += dfs(grid, i, j - 1);
        return count;
    }

## 正则表达式匹配

    public boolean isMatch(String text, String pattern) {
        if (pattern.isEmpty()) {
            return text.isEmpty();
        }
        boolean match = text.charAt(0) == pattern.charAt(0) || pattern.charAt(0) == '.';
        if (pattern.length() > 2 && pattern.charAt(1) == '*') {
            // 匹配0个
            boolean match0 = isMatch(text, pattern.substring(2));
            boolean matchMore = match && isMatch(text.substring(1), pattern);
            return match0 || matchMore;
        }
        return match && isMatch(text.substring(1), pattern.substring(1));
    }


    // 动态规划解法

    class Solution {
        public boolean isMatch(String s, String p) {
            int m = s.length();
            int n = p.length();

            boolean[][] dp = new boolean[m + 1][n + 1];
            dp[0][0] = true;
            for (int i = 0; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    if (p.charAt(j - 1) == '*') {
                        // 首先匹配0个
                        boolean match0 = dp[i][j - 2];
                        boolean matchAny = false;
                        // 如果匹配字符串*前面的字符和当前的s的比较 是相等 则需要进一步判断
                        if (matches(s, p , i, j - 1)) {
                            matchAny = dp[i - 1][j];
                        }
                        dp[i][j] = match0 || matchAny;
                    } else {
                        if (matches(s, p, i, j)) {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    }
                }

            }
            return dp[m][n];
        }

        public boolean matches(String s, String p, int i, int j) {
            // 如果i=0直接false
            if (i == 0) {
                return false;
            }
            if (p.charAt(j - 1) == '.') {
                return true;
            }
            return s.charAt(i - 1) == p.charAt(j - 1);
        }
    }

## 扑克牌中的顺子

    public boolean isStraight(int[] nums) {
        int min = 15;
        int max = 0;
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (num == 0) {
                continue;
            }
            if (set.contains(num)) {
                return false;
            }
            set.add(num);
            min = Math.min(num, min);
            max = Math.max(num, max);
        }
        return max - min < 5;
    }

## 两个站实现一个队列

    Stack<Integer> masterStack = new Stack<>();
    Stack<Integer> slaveStack = new Stack<>();


    public void appendTail(int value) {
        // 直接加到master中
        masterStack.push(value);
    }

    public int deleteHead() {
        // 首先看 slave 中是否有元素 如果有直接移除
        // 否则将master出栈到slave 然后再slave出栈
        if (slaveStack.isEmpty()) {
            if (masterStack.isEmpty()) {
                return -1;
            }
            while (!masterStack.isEmpty()) {
                slaveStack.push(masterStack.pop());
            }
        }
        return slaveStack.pop();
    }

## 有效的括号

    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else if (c == ')' || c == '}' || c == ']') {
                if (stack.isEmpty()) {
                    return false;
                }
                char pop = stack.pop();
                if (c == ')' && pop == '(') {
                    continue;
                } else if (c == '}' && pop == '{') {
                    continue;
                } else if (c == ']' && pop == '[') {
                    continue;
                } else {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

## 逆波兰表达式

    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        Integer num1, num2;
        for (String s: tokens) {
            switch (s) {
                case "+" :
                    stack.push(stack.pop() + stack.pop());
                    break;
                case "-" :
                    num1 = stack.pop();
                    num2 = stack.pop();
                    stack.push(num2 - num1);
                    break;
                case "*" :
                    stack.push(stack.pop() * stack.pop());
                    break;
                case "/" :
                    num1 = stack.pop();
                    num2 = stack.pop();
                    stack.push(num2 / num1);
                    break;
                default:
                    stack.push(Integer.parseInt(s));
                    break;
            }
        }
        return stack.pop();
    }

## Z字型变

    public String convert(String s, int numRows) {

        if (numRows == 1) {
            return s;
        }

        StringBuilder ret = new StringBuilder();
        int n = s.length();
        int cycleLen = 2 * numRows - 2;

        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j + i < n; j += cycleLen) {
                ret.append(s.charAt(j + i));
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n) {
                    ret.append(s.charAt(j + cycleLen - i));
                }
            }
        }
        return ret.toString();
    }

## 字符串相乘

    public String multiply(String num1, String num2) {
        int length1 = num1.length();
        int length2 = num2.length();
        if ("0".equals(num1) || "0".equals(num2)) {
            return "0";
        }
        StringBuilder result = new StringBuilder();
        for (int i = length2 - 1; i >= 0; i--) {
            StringBuilder tempResult = new StringBuilder();
            int carry = 0;
            for (int j = length1 - 1; j >= 0; j--) {
                int number2 = num2.charAt(i) - '0';
                int number1 = num1.charAt(j) - '0';
                int multiplyResult = number2 * number1 + carry;
                carry = multiplyResult / 10;
                tempResult.append(multiplyResult % 10);
            }
            if (carry > 0) {
                tempResult.append(carry);
            }
            StringBuilder reverse = tempResult.reverse();
            for (int k = 0; k < length2 - 1 - i; k++) {
                reverse.append(0);
            }
            result = sum(result.toString(), reverse.toString());
            System.out.println(result);
        }
        return result.toString();
    }

    private StringBuilder sum(String num1, String num2) {
        int length1 = num1.length();
        int length2 = num2.length();
        int i = length1 - 1;
        int j = length2 - 1;
        int carry = 0;
        StringBuilder result = new StringBuilder();
        while (i >= 0 || j >= 0) {
            int number1;
            int number2;
            if (i < 0) {
                number1 = 0;
            } else {
                number1 = num1.charAt(i) - '0';
            }
            if (j < 0) {
                number2 = 0;
            } else {
                number2 = num2.charAt(j) - '0';
            }
            result.append((number1 + number2 + carry) % 10);
            carry = (number1 + number2 + carry) / 10;
            i--;
            j--;
        }
        if (carry > 0) {
            result.append(carry);
        }
        return result.reverse();
    }

## 二叉搜索树的公共祖先

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else {
            return root;
        }
    }
    
## 二叉树展开为链表

    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        preorderTraversal(root, list);
        int size = list.size();
        for (int i = 1; i < size; i++) {
            TreeNode prev = list.get(i - 1), curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }

    public void preorderTraversal(TreeNode root, List<TreeNode> list) {
        if (root != null) {
            list.add(root);
            preorderTraversal(root.left, list);
            preorderTraversal(root.right, list);
        }
    }

## 二叉树的最近公共祖先

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 递归终止条件
        // 当节点为null 或者 等于p或q的时候直接return root
        // 这点表示，如果子树返回给父节点为null 那么公共节点肯定不在该子树中
        // 如果左右两边子树返回的都不是空，那么此时该父节点就是最近祖先
        // 如果 左或者右子树有一个返回的不是空 那么就返回不是空的
        // 这种情况可以分为两种，一种是两个节点都在那里，另一种是分布在其他地方
        // 我们只需要保证 节点为null 或者等于p或q返回root 如果左右节点返回的都不是空则返回该结点
        // 如果有一个不是空则返回不是空的那个节点
        if (root == null || root == p || root == q) {
            return root;
        }
        // 如果终止条件不满足 那么看左右节点返回情况
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果左右节点返回的都不是空 那么这个结点就是最近公共祖先
        if (left != null && right != null) {
            return root;
        }
        // 如果这个结点不是公共祖先 那么向上返回对应的不为空的node 也可能都是为空
        return left == null ? right : left;
    }
    
## 完全二叉树的节点个数

    public int countNodes(TreeNode root) {
        return root == null ? 0 : countNodes(root.left) + countNodes(root.right) + 1;
    }

## 有序数组转换为二分搜索树

    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null) {
            return null;
        }
        this.nums = nums;
        return helper(0, nums.length - 1);
    }

    private TreeNode helper(int l, int r) {
        if (l > r) {
            return null;
        }
        int mid = (r - l) / 2 + l;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = helper(l, mid - 1);
        node.right = helper(mid + 1, r);
        return node;
    }
    
## 平衡二叉树

    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isBalanced(root.left) && isBalanced(root.right)
                && Math.abs(depth(root.left) - depth(root.right)) < 2;
    }

    private int depth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        return Math.max(depth(node.left), depth(node.right)) + 1;
    }

## 有序链表转换为二分搜索树

    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) {
            return null;
        }
        else if(head.next == null) {
            return new TreeNode(head.val);
        }
        ListNode pre = head;
        ListNode p = pre.next;
        ListNode q = p.next;
        //找到链表的中点p
        while(q!=null && q.next!=null){
            pre = pre.next;
            p = pre.next;
            q = q.next.next;
        }
        //将中点左边的链表分开
        pre.next = null;
        TreeNode root = new TreeNode(p.val);
        root.left = sortedListToBST(head);
        root.right = sortedListToBST(p.next);
        return root;
    }

## 树的子结构

    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null) {
            return false;
        }
        return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }

    private boolean dfs(TreeNode A, TreeNode B) {
        if (A == null) {
            return false;
        } else if (B == null) {
            return true;
        }
        return A.val == B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
    }

## 相同的树

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val == q.val) {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
    
## 反转二叉树

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val == q.val) {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
    
## 重建二叉树

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        // 找到根节点 前序遍历的第一个元素是根节点
        int rootValue = preorder[0];
        TreeNode root = new TreeNode(rootValue);
        // 寻找中序遍历中根节点位置 以此来分割左右子树
        int rootIndex = 0;
        for (int i = 0; i < inorder.length; i++) {
            if (inorder[i] == rootValue) {
                rootIndex = i;
                break;
            }
        }
        // 分割数组
        int[] leftPre = Arrays.copyOfRange(preorder, 1, 1 + rootIndex);
        int[] rightPre = Arrays.copyOfRange(preorder, 1 + rootIndex, preorder.length);
        int[] leftIn = Arrays.copyOfRange(inorder, 0, rootIndex);
        int[] rightIn = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length);
        root.left = buildTree(leftPre, leftIn);
        root.right = buildTree(rightPre, rightIn);
        return root;
    }

## 快速排序

    public static void quickSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        int p = partition(nums, l, r);
        quickSort(nums, l, p - 1);
        quickSort(nums, p + 1, r);
    }

    public static int partition(int[] nums, int l, int r) {
        int basicNum = nums[l];
        int j = l;
        for (int i = l + 1; i <= r; i++) {
            if (nums[i] < basicNum) {
                j++;
                SortUtils.swap(nums, i, j);
                // 将小于基准数的都放在j位置左边
            }
        }
        SortUtils.swap(nums, j, l);
        return j;
    }

## 归并排序

    public static void mergeSort(int[] nums, int l, int r) {
        if (l == r) {
            return;
        }
        int mid = (r - l) / 2 + l;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        merge(nums, l, r, mid);
    }

    private static void merge(int[] nums, int l, int r, int mid) {
        // 创建一个新数组用来存储
        int[] newNums = new int[r - l + 1];
        int lIndex = l;
        int rIndex = mid + 1;
        for (int i = 0; i < newNums.length; i++) {
            if (lIndex == mid + 1) {
                newNums[i] = nums[rIndex];
                rIndex++;
                continue;
            } else if (rIndex == r + 1) {
                newNums[i] = nums[lIndex];
                lIndex++;
                continue;
            }
            if (nums[lIndex] < nums[rIndex]) {
                newNums[i] = nums[lIndex];
                lIndex++;
            } else {
                newNums[i] = nums[rIndex];
                rIndex++;
            }
        }
        if (newNums.length >= 0) {
            System.arraycopy(newNums, 0, nums, l, newNums.length);
        }
    }

## 堆排序

    public static void sort(int[] arr) {
        //1.构建大顶堆
        for (int i = arr.length - 1; i >= 0; i--) {
            //从第一个非叶子结点从下至上，从右至左调整结构
            siftDown(arr, i, arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for (int j = arr.length - 1; j >= 0; j--) {
            SortUtils.swap(arr, 0, j);
            siftDown(arr, 0, j);
        }

    }

    private static int left(int index) {
        return index * 2 + 1;
    }


    public static void siftDown(int[] arr, int i, int size) {
        while (left(i) < size) {
            int j = left(i);
            if (j + 1 < size && arr[j + 1] > arr[j]) {
                j++;
            }
            if (arr[i] > arr[j]) {
                break;
            }
            SortUtils.swap(arr, i, j);
            i = j;
        }
    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
    
## 并查集
    
    private int[] id;


    public UnionFindQuickFind() {}

    public UnionFindQuickFind(int size) {
        id = new int[size];
        for (int i = 0; i < id.length; i++) {
            id[i] = i;
        }
    }

    @Override
    public int getSize() {
        return this.id.length;
    }

    @Override
    public boolean isConnected(int i, int j) {
        return find(i) == find(j);
    }

    private int find(int p) {
        if (p < 0 || p >= id.length) {
            throw new IllegalArgumentException("The index is invalid");
        }
        return id[p];
    }

    @Override
    public void unionElements(int i, int j) {
        int iId = find(i);
        int jId = find(j);

        if (iId == jId) {
            return;
        }
        for (int k = 0; k < id.length; k++) {
            if (id[k] == iId) {
                id[k] = jId;
            }
        }

    }